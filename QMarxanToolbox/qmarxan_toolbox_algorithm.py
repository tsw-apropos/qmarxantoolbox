# -*- coding: utf-8 -*-

"""
/***************************************************************************
 QMarxanToolbox
                                 A QGIS plugin
 Create input files for Marxan
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-11-23
        copyright            : (C) 2018 by Apropos Information Systems Inc
        email                : tsw.web@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Apropos Information Systems Inc'
__date__ = '2018-11-23'
__copyright__ = '(C) 2018 by Apropos Information Systems Inc'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from PyQt5.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingException,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterField,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterDefinition,
                       QgsProcessingParameterFileDestination,
                       QgsGeometry,
                       QgsWkbTypes)
import os, sys, datetime, math, numpy, csv
from tempfile import gettempdir
from itertools import islice, cycle
from collections import namedtuple
import heapq

class QMarxanToolboxInputFolders(QgsProcessingAlgorithm):
    """
    This creates the input folders and files for a Marxan project

    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUT_DIR = 'OUT_DIR'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # select input folder
        defDir = os.path.join(os.path.expanduser('~'),'marxanproj1')
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUT_DIR,
                self.tr('Marxan project folder (folder for input.dat and input and output folders)'),
                defDir,
                optional=False
            )
        )


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        #
        # formatAsME - format as Marxan Exponent format like 
        #              Input File Editor
        #
        def formatAsME(inVal):
            outStr = "%.14E" % float(inVal)
            parts = outStr.split('E')
            sign = parts[1][:1]
            exponent = "%04d" % float(parts[1][1:])
            outStr = parts[0] + 'E' +  sign + exponent
            return(outStr)

        dest = self.parameterAsString(parameters, self.OUT_DIR, context)
        if os.path.exists(dest):
            iDir = os.path.join(dest,'input')
            if not os.path.exists(iDir):
                os.mkdir(iDir)
            feedback.setProgress(25)
            oDir = os.path.join(dest,'output')
            if not os.path.exists(oDir):
                os.mkdir(oDir)
            feedback.setProgress(50)
            puDir = os.path.join(dest,'pu')
            if not os.path.exists(puDir):
                os.mkdir(puDir)
            iName = os.path.join(dest,'input.dat')
            feedback.setProgress(75)

            f = open(iName, 'w')
            creditText = "Input file for Annealing program.\n\n"
            creditText += "This file generated by QMarxan Toolbox 1.1.1\n"
            creditText += "created by Apropos Information Systems Inc.\n\n"
            f.write(creditText)
            f.write("General Parameters\n")
            f.write("VERSION 0.1\n")
            f.write("BLM %s\n" % (formatAsME(1.0)))
            f.write("PROP %s\n" % (formatAsME(0.5)))
            f.write("RANDSEED -1\n")
            f.write("NUMREPS 100\n")
            f.write("\nAnnealing Parameters\n")
            f.write("NUMITNS 1000000\n")
            f.write("STARTTEMP %s\n" % (formatAsME(-1.0)))
            f.write("COOLFAC %s\n" % (formatAsME(-1.0)))
            f.write("NUMTEMP 10000\n")
            f.write("\nCost Threshold\n")
            f.write("COSTTHRESH %s\n" % (formatAsME(0.0)))
            f.write("THRESHPEN1 %s\n" % (formatAsME(0.0)))
            f.write("THRESHPEN2 %s\n" % (formatAsME(0.0)))
            f.write("\nInput Files\n")
            f.write("INPUTDIR input\n")
            f.write("SPECNAME spec.dat\n")
            f.write("PUNAME pu.dat\n")
            f.write("PUVSPRNAME puvsp.dat\n")
            f.write("BOUNDNAME bound.dat\n")
            f.write("MATRIXSPORDERNAME puvsp_sporder.dat\n")
            f.write("\nSave Files\n")
            f.write("SCENNAME output\n")
            f.write("SAVERUN 3\n")
            f.write("SAVEBEST 3\n")
            f.write("SAVESUMMARY 3\n")
            f.write("SAVESCEN 3\n")
            f.write("SAVETARGMET 3\n")
            f.write("SAVESUMSOLN 3\n")
            f.write("SAVELOG 3\n")
            f.write("SAVESNAPSTEPS 0\n")
            f.write("SAVESNAPCHANGES 0\n")
            f.write("SAVESNAPFREQUENCY 0\n")
            f.write("OUTPUTDIR output\n")
            f.write("%sProgram control.\n")
            f.write("RUNMODE 1\n")
            f.write("MISSLEVEL %s\n" % formatAsME(0.95))
            f.write("ITIMPTYPE 1\n")
            f.write("HEURTYPE -1\n")
            f.write("CLUMPTYPE 0\n")
            f.write("VERBOSITY 2\n")
            f.write("SAVESOLUTIONSMATRIX 3\n")
            f.write("\n")
            f.close()
            feedback.setProgress(99)
            # return results
            return {"Success": "Files and folder creation successful"}
        else:
            failureMessage = 'Folder "' + dest + '" does not exist'
            return {"Failure": failureMessage}

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'inputfolders'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        #return self.tr(self.name())
        return "Create Input File and Folders"

#    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        #return self.tr(self.groupId())
#        return 'Configuration'

#    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
#        return 'configuration'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return QMarxanToolboxInputFolders()

class QMarxanToolboxExportBoundaryFile(QgsProcessingAlgorithm):
    """
    This creates the input folders and files for a Marxan project

    """
    
    # The following merge and batch_sort code is from:
    #
    # Author: Gabriel Genellina 2009-05-14
    # License: MIT
    # Source: http://code.activestate.com/recipes/576755/

    # based on Recipe 466302: Sorting big files the Python 2.4 way
    # by Nicolas Lehuen

    Keyed = namedtuple("Keyed", ["key", "obj"])

    def merge(self, key=None, *iterables):
        # based on code posted by Scott David Daniels in c.l.p.
        # http://groups.google.com/group/comp.lang.python/msg/484f01f1ea3c832d

        if key is None:
            for element in heapq.merge(*iterables):
                yield element
        else:
            keyed_iterables = [(Keyed(key(obj), obj) for obj in iterable)
                            for iterable in iterables]
            for element in heapq.merge(*keyed_iterables):
                yield element.obj


    def batch_sort(self, inputFile, outputFile, key=None, buffer_size=32000, tempdirs=None):
        if tempdirs is None:
            tempdirs = []
        if not tempdirs:
            tempdirs.append(gettempdir())

        chunks = []
        try:
            with open(inputFile,'rb',64*1024) as input_file:
                input_iterator = iter(input_file)
                for tempdir in cycle(tempdirs):
                    current_chunk = list(islice(input_iterator,buffer_size))
                    if not current_chunk:
                        break
                    current_chunk.sort(key=key)
                    output_chunk = open(os.path.join(tempdir,'%06i'%len(chunks)),'w+b',64*1024)
                    chunks.append(output_chunk)
                    output_chunk.writelines(current_chunk)
                    output_chunk.flush()
                    output_chunk.seek(0)
            with open(outputFile,'wb',64*1024) as output_file:
                output_file.writelines(self.merge(key, *chunks))
        finally:
            for chunk in chunks:
                try:
                    chunk.close()
                    os.remove(chunk.name)
                except Exception:
                    pass
                    
    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    PU_LAYER = 'PU_LAYER'
    PU_FIELD = 'PU_FIELD'
    BND_METHOD = 'BND_METHOD'
    BND_TREAT = 'BND_TREAT'
    BND_VALUE = 'BND_VALUE'
    CALC_FIELD = 'CALC_FIELD'
    CALC_METHOD = 'CALC_METHOD'
    TOL = 'TOL'
    OUT_DIR = 'OUT_DIR'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # pu layer
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PU_LAYER,
                self.tr('Planning unit layer (source for bound.dat file)'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )
        # pu id
        self.addParameter(
            QgsProcessingParameterField(
                self.PU_FIELD,
                self.tr('Planning unit id field'),
                parentLayerParameterName=self.PU_LAYER,
                type=QgsProcessingParameterField.Numeric
            )
        )
        #
        # advanced settings
        #
        #  bnd method
        bndMethod = QgsProcessingParameterEnum(
            self.BND_METHOD,
            self.tr('Boundary method (how lengths between planning units will be set)'),
            options = ["Single","Measured","Weighted","Field"],
            defaultValue = 0
        )
        bndMethod.setFlags(bndMethod.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(bndMethod)
        # bnd treatment
        bndTreatment = QgsProcessingParameterEnum(
            self.BND_TREAT,
            self.tr('Boundary treatment (how values for PUs on perimeter of study area will be set)'),
            options = ["Full Value","Half Value","Exclude"],
            defaultValue = 0
        )
        bndTreatment.setFlags(bndTreatment.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(bndTreatment)
        # single value
        bndValue = QgsProcessingParameterNumber(
            self.BND_VALUE,
            self.tr('Boundary value (value for all boundaries regardless of measured length)'),
            type=QgsProcessingParameterNumber.Integer, 
            minValue=0, 
            defaultValue=1,
            optional=True
        )
        bndValue.setFlags(bndValue.flags() | QgsProcessingParameterDefinition.FlagAdvanced )
        self.addParameter(bndValue)
        # calculation field
        calcField = QgsProcessingParameterField(
            self.CALC_FIELD,
            self.tr('Calculation field (field to weight or assign boundary lengths)'),
            parentLayerParameterName=self.PU_LAYER,
            type=QgsProcessingParameterField.Numeric,
            optional = True
        )
        calcField.setFlags(calcField.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(calcField)
        # calculation method
        calcMethod = QgsProcessingParameterEnum(
            self.CALC_METHOD,
            self.tr('Calculation method (how to assign boundary length if values between adjacent planning units differ)'),
            options = ["Mean","Maximum","Minimum"],
            defaultValue = 0,
            optional = True
        )
        calcMethod.setFlags(calcMethod.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(calcMethod)
        # rounding precision
        tolerance = QgsProcessingParameterEnum(
            self.TOL,
            self.tr('Export precision tolerance (in map units)'),
            options = ["100","10","1","0.1","0.01","0.001","0.0001","0.00001"],
            defaultValue = 3
        )
        tolerance.setFlags(tolerance.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(tolerance)

        # select output folder
        defDir = os.path.join(os.path.expanduser('~'),'marxanproj1','input')
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUT_DIR,
                self.tr('Marxan input folder (place to write bound.dat file)'),
                defDir,
                optional=False
            )
        )

    def checkParameterValues(self, parameters, context):
        
        result = (True,'Selected inputs ok')
        
        # get parameters for validation
        bndIdx = self.parameterAsInt(parameters,self.BND_METHOD,context)
        if bndIdx == 0:
            bndMethod = 'Single'
        elif bndIdx == 1:
            bndMethod = 'Measure'
        elif bndIdx == 2:
            bndMethod = 'Weighted'
        else:
            bndMethod = 'Field'
        bndValue = self.parameterAsInt(parameters,self.BND_VALUE,context)
        calcField = self.parameterAsString(parameters,self.CALC_FIELD,context)
        outDir = self.parameterAsString(parameters,self.OUT_DIR,context)
        # validate options to ensure that choices are valid
        if bndMethod in ('Weighted','Field') and calcField in ('None',''):
            result = (False,'The weighted and field methods require a boundary length field')
        if bndMethod == 'Single' and bndValue <= 0:
            result = (False, 'A value greater than zero must be set if the single boundary method is selected')
        if not os.path.exists(outDir):
            result = (False, 'The output directory must exist')

        return result        

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # calculate line length
        def LineLength(p1,p2):
            ll = math.sqrt( (float(p1[0]) - float(p2[0]))**2 + \
                (float(p1[1]) - float(p2[1]))**2 )
            return(ll)

        # extract points from polygon
        # modified from ftools_utils.py by Carson Farmer
        def extractPoints( geom ):
            multi_geom = QgsGeometry()
            temp_geom = []
            if geom.isMultipart():
                multi_geom = geom.asMultiPolygon() #multi_geom is a multipolygon
                for i in multi_geom: #i is a polygon
                    for j in i: #j is a line
                        temp_geom.extend( j )
            else:
                multi_geom = geom.asPolygon() #multi_geom is a polygon
                for i in multi_geom: #i is a line
                    temp_geom.extend( i )
            return(temp_geom)

        # adjust boundary length
        def adjBound(inVal,id1,id2):
            if id1 == id2:
                if self.bndTreat == 'Full Value':
                    retVal = inVal
                elif self.bndTreat == 'Half Value':
                    retVal = inVal/2.0
                else:
                    retVal = 0.0
            else:
                retVal = inVal
            return(retVal)

        # get parameters
        self.puLayer = self.parameterAsVectorLayer(parameters,self.PU_LAYER,context)
        self.puField = self.parameterAsString(parameters,self.PU_FIELD,context)
        self.bndIdx = self.parameterAsInt(parameters,self.BND_METHOD,context)
        if self.bndIdx == 0:
            self.bndMethod = 'Single'
        elif self.bndIdx == 1:
            self.bndMethod = 'Measure'
        elif self.bndIdx == 2:
            self.bndMethod = 'Weighted'
        else:
            self.bndMethod = 'Field'
        self.bndValue = self.parameterAsInt(parameters,self.BND_VALUE,context)
        self.bndField = self.parameterAsString(parameters,self.CALC_FIELD,context)
        self.calcIdx = self.parameterAsInt(parameters,self.CALC_METHOD,context)
        if self.calcIdx == 0:
            self.calcMethod = 'Mean'
        elif self.calcIdx == 1:
            self.calcMethod = 'Maximum'
        else:
            self.calcMethod = 'Minimum'
        self.bndTreatIdx = self.parameterAsInt(parameters,self.BND_TREAT,context)
        if self.bndTreatIdx == 0:
            self.bndTreat = 'Full Value'
        elif self.bndTreatIdx == 1:
            self.bndTreat = 'Half Value'
        else:
            self.bndTreat = 'Exclude'
        # note that tolerance here is set to the index -2 because
        # the third item, is round numbers so 2 - 2 is zero and
        # round(125.12,0) => 125 and round(125.12,-2) => 100
        self.tol = self.parameterAsInt(parameters,self.TOL,context) - 2
        self.outDir = self.parameterAsString(parameters,self.OUT_DIR,context)
        self.outFName = os.path.join(self.outDir,'bound.dat')
        
        #
        # pre-run setup
        #
        # track # of possible topological errors
        topoErrorCount = 0
        # change to output directory
        path,fname = os.path.split(self.outFName)
        os.chdir(path)
        # create temporary file names 
        tempsegfile = 'tempsegfile_%s.txt' % os.getpid()
        tempsortedfile = 'tempsortedfile_%s.txt' % os.getpid()
        tempadjfile = 'tempadjfile_%s.txt' % os.getpid()
        tempsortedadjfile = 'tempsortedadjfile_%s.txt' % os.getpid()
        errorlog = 'topo_error_log_%s.txt' % datetime.date.today().isoformat()
        # get field indexes for puid and boundary fields
        puIdx = self.puLayer.dataProvider().fields().indexFromName(self.puField)
        if self.bndField != None:
            fldIdx = self.puLayer.dataProvider().fields().indexFromName(self.bndField)
        else:
            fldIdx = -1
        #
        # step 1 - build temporary segment file and dictionary
        #
        # notify users
        feedback.setProgress(0)
        # set values
        tsf = open(tempsegfile,'w')
        inGeom = QgsGeometry()
        segLineCnt = 0
        # loop through features
        lineCount = 0
        fCount = self.puLayer.dataProvider().featureCount()
        x = 0
        progPct = 0
        progMin = 0
        progMax = 30
        progPct = progMin
        lastPct = progPct
        progRange = progMax - progMin
        for feat in self.puLayer.getFeatures():
            x += 1
            progPct = ((float(x) / float(fCount) * 100) * (progRange/100.0)) + progMin
            if int(progPct) > lastPct:
                feedback.setProgress(progPct)
                lastPct = progPct
            attr = feat.attributes()
            pid = int(attr[puIdx])
            if fldIdx != -1:
                cost = str(attr[fldIdx])
            else:
                cost = '1.0'
            inGeom = feat.geometry()
            pointList = extractPoints(inGeom)
            prevPoint = 0
            for i in pointList:
                if prevPoint == 0:
                    prevPoint = i
                else:
                    # write line segment
                    segLen = LineLength([prevPoint[0],prevPoint[1]], [i[0],i[1]])
                    # make spatial key to segment file
                    if round(float(prevPoint[0]),self.tol) < round(float(i[0]),self.tol) or \
                        (round(float(prevPoint[0]),self.tol) == round(float(i[0]),self.tol) \
                        and round(float(prevPoint[1]),self.tol) < round(float(i[1]),self.tol) ):
                        skey = str(round(float(prevPoint[0]),self.tol)) + '|' + \
                            str(round(float(prevPoint[1]),self.tol)) + '|' + \
                            str(round(float(i[0]),self.tol)) + '|' +  \
                            str(round(float(i[1]),self.tol))
                    else:
                        skey = str(round(float(i[0]),self.tol)) + '|' +  \
                            str(round(float(i[1]),self.tol)) + '|' + \
                            str(round(float(prevPoint[0]),self.tol)) + '|' + \
                            str(round(float(prevPoint[1]),self.tol))
                    if segLen > 0:
                        outLine = '%s,%d,%f,%f\n' %  (skey, int(pid), float(cost), segLen)
                        tsf.write(outLine)
                        lineCount += 1
                    prevPoint = i
        # clean up
        tsf.close()
        # sort the file
        self.batch_sort(tempsegfile, tempsortedfile)
        os.remove(tempsegfile)
        #
        # step 2 - loop through sorted file and create adjacency file
        #    
        # notify users
        # 
        tsf = open(tempsortedfile,'r')
        taf = open(tempadjfile,'w')
        done = False
        pl = ''
        x = 0
        adjFileLen = 0
        progMin = 35
        progMax = 65
        progPct = progMin
        lastPct = progPct
        progRange = progMax - progMin
        while not done:
            x += 1
            progPct = ((float(x) / float(lineCount) * 100) * (progRange/100.0)) + progMin
            if int(progPct) > lastPct:
                feedback.setProgress(progPct)
                lastPct = progPct
            line = tsf.readline()
            if line == '':
                done = True
            else:
                cl = line.rstrip().split(',')
            if pl != '' and pl != ['']:
                if cl != '' and pl[0] == cl[0]:
                    fCost = 1
                    if self.bndMethod == 'Single':
                        fCost = str(self.bndValue)
                    elif self.bndMethod == 'Field':
                        bCost = 1
                        if float(pl[2])== float(cl[2]):
                            bCost = float(pl[2])
                        else:
                            if self.calcMethod == 'Maximum':
                                bCost = max([float(pl[2]),float(cl[2])])
                            elif self.calcMethod == 'Minimum':
                                bCost = min([float(pl[2]),float(cl[2])])
                            else:
                                bCost = (float(pl[2]) + float(cl[2]))/2.0
                        fCost = str(bCost)
                    elif self.bndMethod  == 'Weighted':
                        bCost = 1
                        if float(pl[2])== float(cl[2]):
                            bCost = float(pl[2])
                        else:
                            if self.calcMethod == 'Maximum':
                                bCost = max([float(pl[2]),float(cl[2])])
                            elif self.calcMethod == 'Minimum':
                                bCost = min([float(pl[2]),float(cl[2])])
                            else:
                                bCost = sum([float(pl[2]),float(cl[2])])/2.0
                        fCost = str(float(pl[3]) * bCost)
                    else:
                        fCost = str(pl[3])
                    # topology error test
                    # check for more matching lines
                    errorLines = True
                    topologyErrorFound = False
                    pids = ''
                    while errorLines:
                        line = tsf.readline()
                        chkLine = line.rstrip().split(',')
                        if chkLine != '' and chkLine[0] == pl[0]:
                            topologyErrorFound = True
                            # an error exists
                            if pids == '':
                                pids = str(pl[1]) + ',' + str(cl[1]) + ',' + str(chkLine[1])
                            else:
                                pids = pids + ',' + str(chkLine[1])
                        else:
                            errorLines = False
                    if topologyErrorFound:
                        if topoErrorCount == 0:
                            el = open(errorlog, 'w')
                            outline = 'There should never be more than 2 overlapping ' + \
                                'line segments. \n' + \
                                'Below are listed cases where more than 2 have ' + \
                                'been identified. \n' + 'These should all be ' + \
                                'corrected before using the boundary file\n' + \
                                '-------\n' 
                            el.write(outline)
                        outline = 'Line segments defined as %s may be topologically invalid.\n' % (str(pl[0]))
                        outline = outline + 'Area ids %s appear to overlap.\n--\n' % (pids) 
                        el.write(outline)
                        topoErrorCount += 1
                    else:
                        # no error proceed
                        if int(pl[1]) < int(cl[1]):
                            taf.write('%020d,%020d,%s\n' % (int(pl[1]),int(cl[1]),fCost))
                        else:
                            taf.write('%020d,%020d,%s\n' % (int(cl[1]),int(pl[1]),fCost))
                        adjFileLen += 1
                elif type(pl) == list:
                    fCost = 1
                    if self.bndMethod == 'Single':
                        fCost = str(self.bndValue)
                    elif self.bndMethod  == 'Field':
                        fCost = str(pl[2])
                    elif self.bndMethod  == 'Weighted':
                        fCost = str(float(pl[3]) * float(pl[2]))
                    else:
                        fCost = str(pl[3])
                    taf.write('%020d,%020d,%s\n' % (int(pl[1]),int(pl[1]),fCost))
            pl = line.rstrip().split(',')
        tsf.close()
        taf.close()
        os.remove(tempsortedfile)
        # sort adjacency file
        self.batch_sort(tempadjfile, tempsortedadjfile)
        os.remove(tempadjfile)
        #
        # step 3 - write boundary file
        #
        # notify users
        #
        saf = open(tempsortedadjfile,'r')
        faf = open(self.outFName,'w')
        faf.write("id1\tid2\tboundary\n")
        done = False
        pl = ''
        x = 0
        progMin = 70
        progMax = 99
        progPct = progMin
        lastPct = progPct
        progRange = progMax - progMin
        while not done:
            x += 1
            progPct = ((float(x) / float(adjFileLen) * 100) * (progRange/100.0)) + progMin
            if int(progPct) > lastPct:
                feedback.setProgress(progPct)
                lastPct = progPct
            line = saf.readline()
            if line == '':
                done = True
                cl = ''
            else:
                cl = line.rstrip().split(',')
            if pl != '':
                if cl != '' and pl[0] == cl[0] and pl[1] == cl[1]:
                    if self.bndMethod  == 'Measured' or self.bndMethod == 'Weighted':
                        # NOTE: 
                        # If weighted or measured methods are used
                        # then all the segments' lengths are added together
                        #
                        # If Single or Field methods are used
                        # then only the first rows values are used as all 
                        # other rows are redundant
                        pl = [pl[0],pl[1],sum([float(pl[2]),float(cl[2])])]
                else:
                    bound = adjBound(float(pl[2]),pl[0],pl[1])
                    if self.bndMethod  in ('Field','Weighted'):
                        boundStr = str(bound)
                    else:
                        boundStr = str(round(float(bound),self.tol))
                    if float(bound) > 0.0:
                        faf.write('%d\t%d\t%s\n' % (int(pl[0]),int(pl[1]),boundStr))
                    pl = line.rstrip().split(',')
            else:
                pl = cl
        saf.close()
        faf.close()
        os.remove(tempsortedadjfile)
        if topoErrorCount > 0:
            el.close()
            messageText = '%d possible topological error(s) found. ' % topoErrorCount
            messageText += 'Please check error log in same directory as boundary file.'
            return {'Failure': messageText}
 
        return {'Success': 'Boundary file successfully written'}


    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'exportboundaryfile'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        #return self.tr(self.name())
        return "Export Boundary File"

#    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        #return self.tr(self.groupId())
#        return 'Export'

#    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
#        return 'export'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return QMarxanToolboxExportBoundaryFile()

class QMarxanToolboxFeatureFile(QgsProcessingAlgorithm):
    """
    This creates the input folders and files for a Marxan project

    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    PU_LAYER = 'PU_LAYER'
    PU_FIELD = 'PU_FIELD'
    FEAT_FIELDS = 'FEAT_FIELDS'
    OUT_DIR = 'OUT_DIR'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # pu layer
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PU_LAYER,
                self.tr('Planning unit layer (with feature / species values)'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )
        # pu id
        self.addParameter(
            QgsProcessingParameterField(
                self.PU_FIELD,
                self.tr('Planning unit id field'),
                parentLayerParameterName=self.PU_LAYER,
                type=QgsProcessingParameterField.Numeric
            )
        )
        # feature fields
        self.addParameter(
            QgsProcessingParameterField(
                self.FEAT_FIELDS,
                self.tr('Feature fields (values for each feature / species of interest)'),
                defaultValue=None, 
                parentLayerParameterName=self.PU_LAYER,
                type=QgsProcessingParameterField.Numeric, 
                allowMultiple=True
            )
        )
        # select output folder
        defDir = os.path.join(os.path.expanduser('~'),'marxanproj1','input')
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUT_DIR,
                self.tr('Marxan input folder (place to write spec.dat, puvsp.dat and puvsp_sporder.dat files)'),
                defDir,
                optional=False
            )
        )
        
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # get parameters
        self.puLayer = self.parameterAsVectorLayer(parameters,self.PU_LAYER,context)
        self.puField = self.parameterAsString(parameters,self.PU_FIELD,context)
        self.fieldList = self.parameterAsFields(parameters,self.FEAT_FIELDS,context)
        self.outDir = self.parameterAsString(parameters,self.OUT_DIR,context)
        # create field list
        fldsRef = []
        flds =[]
        flds.append(self.puField)
        x = 0
        # NOTE: in the spec.dat file
        # x is the id field (referenced in puvsp.dat and puvsp_sporder.dat)
        # the field name becomes the name field
        for fld in self.fieldList:
            x += 1
            fldsRef.append([x,fld])
            flds.append(fld)
        #
        # create spec.dat file
        #
        feedback.setProgress(10)
        specFName = os.path.join(self.outDir,'spec.dat')
        # make copy of old spec.dat file so SPF and targets are not lost
        if os.path.exists(specFName):
            nName = specFName + '.backup_%s' % datetime.datetime.now().isoformat()[:19].replace(':','').replace('-','')
            os.rename(specFName,nName)
        header = 'id\tprop\ttarget\ttargetocc\tspf\tname\n'
        f = open(specFName,'w')
        f.write(header)
        for rec in fldsRef:
            f.write('%d\t0.0\t0.0\t0\t1.0\t%s\n' % (rec[0],rec[1]))
        f.close()
        feedback.setProgress(20)        
        #
        # create puvsp.dat and puvsp_sporder.dat files
        #
        f1 = os.path.join(self.outDir,'puvsp.dat')
        f2 = os.path.join(self.outDir,'puvsp_sporder.dat')
        unOrdered = []
        x = 0
        progMin = 20
        progMax = 70
        progPct = progMin
        lastPct = progPct
        progRange = progMax - progMin
        fCount = self.puLayer.dataProvider().featureCount()
        # step through file and put data into unordered list
        for feat in self.puLayer.getFeatures():
            x += 1
            progPct = ((float(x) / float(fCount) * 100) * (progRange/100.0)) + progMin
            if int(progPct) > lastPct:
                feedback.setProgress(progPct)
                lastPct = progPct
            for rec in fldsRef:
                fldValue = feat[rec[1]]
                if fldValue > 0:
                    speciesId = rec[0]
                    puId = feat[self.puField]
                    unOrdered.append((speciesId,puId,fldValue))
        # use numpy to sort it quickly
        dtype = [('species', int),('pu', int),('amount', float)]
        npArray = numpy.array(unOrdered,dtype=dtype)
        # create puvsp order
        sList = list(numpy.sort(npArray, order=['pu','species']))
        feedback.setProgress(75)
        # write results
        puf = open(f1, 'w')
        puf.write("species\tpu\tamount\n")
        for rec in sList:
            puf.write('%d\t%d\t%f\n' % (rec[0],rec[1],rec[2]))
        puf.close()
        feedback.setProgress(85)
        # create puvsp_sporder order
        sList = list(numpy.sort(npArray,order=['species','pu']))
        feedback.setProgress(89)
        # write results
        spf = open(f2, 'w')
        spf.write("species\tpu\tamount\n")
        for rec in sList:
            spf.write('%d\t%d\t%f\n' % (rec[0],rec[1],rec[2]))
        spf.close()
        feedback.setProgress(99)

        return {'Success': 'spec.dat, puvsp.data and puvsp_sporder.dat successfully written'}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'exportfeaturefiles'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        #return self.tr(self.name())
        return "Export Feature Files"

#    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        #return self.tr(self.groupId())
#        return 'Export'

#    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
#        return 'export'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return QMarxanToolboxFeatureFile()

class QMarxanToolboxExportPlanningUnitFile(QgsProcessingAlgorithm):
    """
    This creates the input folders and files for a Marxan project

    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    PU_LAYER = 'PU_LAYER'
    PU_FIELD = 'PU_FIELD'
    COST_FIELD = 'COST_FIELDS'
    STATUS_FIELD = 'STATUS_FIELD'
    OUT_DIR = 'OUT_DIR'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # pu layer
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.PU_LAYER,
                self.tr('Planning unit layer'),
                [QgsProcessing.TypeVectorPolygon],
                
            )
        )
        # pu id
        self.addParameter(
            QgsProcessingParameterField(
                self.PU_FIELD,
                self.tr('Planning unit id field'),
                parentLayerParameterName=self.PU_LAYER,
                type=QgsProcessingParameterField.Numeric
            )
        )
        # cost field
        self.addParameter(
            QgsProcessingParameterField(
                self.COST_FIELD,
                self.tr('Planning unit cost field (costs for each planning unit)'),
                parentLayerParameterName=self.PU_LAYER,
                type=QgsProcessingParameterField.Numeric
            )
        )
        # status field
        self.addParameter(
            QgsProcessingParameterField(
                self.STATUS_FIELD,
                self.tr('Planning unit status field (status values for each planning unit)'),
                parentLayerParameterName=self.PU_LAYER,
                type=QgsProcessingParameterField.Numeric
            )
        )
        # select output folder
        defDir = os.path.join(os.path.expanduser('~'),'marxanproj1','input')
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUT_DIR,
                self.tr('Marxan input folder (place to write pu.dat file)'),
                defDir,
                optional=False
            )
        )

 
    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # get parameters
        self.puLayer = self.parameterAsVectorLayer(parameters,self.PU_LAYER,context)
        self.puField = self.parameterAsString(parameters,self.PU_FIELD,context)
        self.costField = self.parameterAsString(parameters,self.COST_FIELD,context)
        self.statusField = self.parameterAsString(parameters,self.STATUS_FIELD,context)
        self.outDir = self.parameterAsString(parameters,self.OUT_DIR,context)
        self.outFName = os.path.join(self.outDir,'pu.dat')
        #
        # Step 1 - pull data from shape file
        #
        fCount = self.puLayer.dataProvider().featureCount()
        x = 0
        progPct = 0
        progMin = 0
        progMax = 45
        progPct = progMin
        lastPct = progPct
        progRange = progMax - progMin
        puData = []
        for feat in self.puLayer.getFeatures():
            x += 1
            progPct = ((float(x) / float(fCount) * 100) * (progRange/100.0)) + progMin
            if int(progPct) > lastPct:
                feedback.setProgress(progPct)
                lastPct = progPct
            # get values
            puId = int(feat[self.puField])
            costValue = float(feat[self.costField])
            statusValue = int(feat[self.statusField])
            # add them to the array unless invalid
            if statusValue > 3:
                return{'Failure','Invalid status values. Planning Unit Id: %d, Status Value: %d' % (puId,statusValue)}
            else:
                puData.append([puId,costValue,statusValue])
        # sort data
        puData.sort()
        #
        # Step 2 - write file
        #
        tmpf = open(self.outFName, 'w')
        tmpf.write("id,cost,status\n")
        x = 0
        progMin = 50
        progMax = 99
        progPct = progMin
        lastPct = progPct
        progRange = progMax - progMin
        for row in puData:
            x += 1
            progPct = ((float(x) / float(fCount) * 100) * (progRange/100.0)) + progMin
            if int(progPct) > lastPct:
                feedback.setProgress(progPct)
                lastPct = progPct
            outText = '%d,%f,%d\n' % (row[0],row[1],row[2])
            tmpf.write(outText)
        tmpf.close()

        return {'Success': 'pu.dat successfully written'}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'exportplanningunitfile'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        #return self.tr(self.name())
        return "Export Planning Unit File"

#    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        #return self.tr(self.groupId())
#        return 'Export'

#    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
#        return 'export'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return QMarxanToolboxExportPlanningUnitFile()

class QMarxanToolboxReportFeatures(QgsProcessingAlgorithm):
    """
    This creates the input folders and files for a Marxan project

    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    PU_LAYER = 'PU_LAYER'
    PU_FIELD = 'PU_FIELD'
    IN_DIR = 'IN_DIR'
    OUT_FILE = 'OUT_FILE'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # pu layer
        self.addParameter(QgsProcessingParameterFeatureSource(
                self.PU_LAYER,
                self.tr('Planning unit layer (with some of the planning units selected)'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )
        # pu id
        self.addParameter(
            QgsProcessingParameterField(
                self.PU_FIELD,
                self.tr('Planning unit id field'),
                parentLayerParameterName=self.PU_LAYER,
                type=QgsProcessingParameterField.Numeric
            )
        )
        # select input folder
        defDir = os.path.join(os.path.expanduser('~'),'marxanproj1','input')
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.IN_DIR,
                self.tr('Marxan input folder (with spec.data and puvsp.dat files)'),
                defDir,
                optional=False
            )
        )
        # output file
        defFile = os.path.join(os.path.expanduser('~'),'marxanproj1','report.csv')
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUT_FILE,
                self.tr('Report output file name'),
                self.tr('CSV files (*.csv)'), 
                None, 
                True
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        source = self.parameterAsSource(parameters, self.PU_LAYER, context)
        puField = self.parameterAsString(parameters,self.PU_FIELD,context)
        fName = self.parameterAsString(parameters,self.OUT_FILE,context)
        inDir = self.parameterAsString(parameters,self.IN_DIR,context)
        puCount = source.featureCount()
        # 
        # step 1 - get pu id list
        #
        x = 0
        progPct = 0
        progMin = 0
        progMax = 80
        progPct = progMin
        lastPct = progPct
        progRange = progMax - progMin
        puIdList = []
        for feat in source.getFeatures():
            x += 1
            progPct = ((float(x) / float(puCount) * 100) * (progRange/100.0)) + progMin
            if int(progPct) > lastPct:
                feedback.setProgress(progPct)
                lastPct = progPct
            puIdList.append(int(feat[puField]))
        # sort by puid 
        puIdList.sort()
        # 
        # step 2 - read spec file to get internal feature ids
        #
        specFile = os.path.join(inDir,'spec.dat')
        if os.path.exists(specFile):
            sniffer = csv.Sniffer()
            f = open(specFile,'r')
            contents = f.readlines()
            f.close()
            dialect = sniffer.sniff(contents[0])
            if dialect.delimiter not in (',','\t'):
                return {'Failure','spec.dat format not recognized'}
            specRecs = {}
            for specLine in contents:
                vals = specLine.strip().split(dialect.delimiter)
                if vals[0] != 'id':
                    specRecs[int(vals[0])] = vals[5]
        else:
            return {'Failure','Unable to find or read spec.dat file'}
        feedback.setProgress(85)
        # 
        # step 3 - read puvsp file 
        #
        # aggregate data
        puvspFile = os.path.join(inDir,'puvsp.dat')
        if os.path.exists(puvspFile):
            # count lines using raw count for speed
            f = open(puvspFile, 'rb')
            lCount = 0
            buf_size = 1024 * 1024
            read_f = f.read
            buf = read_f(buf_size)
            while buf:
                lCount += buf.count(b'\n')
                buf = read_f(buf_size)
            f.close()
            # now read through the contents
            featSummary = {}
            with open(puvspFile,'r') as csvfile:
                qmdReader = csv.DictReader(csvfile,delimiter='\t')
                x = 0
                progPct = 0
                progMin = 85
                progMax = 95
                progPct = progMin
                lastPct = progPct
                progRange = progMax - progMin
                for line in qmdReader:
                    x += 1
                    progPct = ((float(x) / float(puCount) * 100) * (progRange/100.0)) + progMin
                    if int(progPct) > lastPct:
                        feedback.setProgress(progPct)
                        lastPct = progPct
                    if int(line['pu']) in puIdList:
                        if line['species'] in featSummary:
                            featSummary[line['species']][0] += 1
                            featSummary[line['species']][1] += float(line['amount'])
                        else:
                            featSummary[line['species']] = [1,float(line['amount'])]
        else:
            return {'Failure','Unable to find or read puvsp.dat file'}
        # convert to list to sort
        summaryList = [[int(key),value[0],value[1]] for key, value in featSummary.items()]
        summaryList.sort()
        feedback.setProgress(98)
        # 
        # step 4 - write file
        #
        # write report
        f = open(fName,'w')
        f.write('featureId,featureName,featureCount,selectedPuCount,occurrencePercent,featureSum\n')
        for rec in summaryList:
            f.write('%d,%s,%d,%d,%f,%f\n' % (rec[0],specRecs[rec[0]],rec[1],puCount,float(rec[1])/float(puCount)*100,rec[2]) )
        f.close()
        
        return {'Success': '%s written successfully' % fName}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'reportfeatures'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        #return self.tr(self.name())
        return "Report Features for Selected Planning Units"

#    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        #return self.tr(self.groupId())
#        return 'Report'

#    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
#        return 'report'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return QMarxanToolboxReportFeatures()

